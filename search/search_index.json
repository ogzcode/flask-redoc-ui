{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Flask Pydantic ReDoc Flask Pydantic ReDoc is an extension that allows you to generate OpenAPI documentation for your Flask applications. It helps you document your APIs using Pydantic models and view them through the ReDoc UI. Features \u2728 Schema generation with Pydantic models \ud83d\udcdd Automatic documentation from docstrings in Flask routes \ud83c\udfa8 Modern and user-friendly interface with ReDoc UI \ud83d\udd04 OpenAPI 3.0.2 support \ud83d\udee0\ufe0f Easy configuration Documentation For detailed information, you can explore the following sections: Installation Guide Getting Started Guide Pydantic Integration Contact For any questions, suggestions, or feedback, you can reach us through the following channels: GitHub : github.com/ogzcode/flask-redoc-ui For bug reports and feature requests, please open an issue on GitHub.","title":"Home"},{"location":"#flask-pydantic-redoc","text":"Flask Pydantic ReDoc is an extension that allows you to generate OpenAPI documentation for your Flask applications. It helps you document your APIs using Pydantic models and view them through the ReDoc UI.","title":"Flask Pydantic ReDoc"},{"location":"#features","text":"\u2728 Schema generation with Pydantic models \ud83d\udcdd Automatic documentation from docstrings in Flask routes \ud83c\udfa8 Modern and user-friendly interface with ReDoc UI \ud83d\udd04 OpenAPI 3.0.2 support \ud83d\udee0\ufe0f Easy configuration","title":"Features"},{"location":"#documentation","text":"For detailed information, you can explore the following sections: Installation Guide Getting Started Guide Pydantic Integration","title":"Documentation"},{"location":"#contact","text":"For any questions, suggestions, or feedback, you can reach us through the following channels: GitHub : github.com/ogzcode/flask-redoc-ui For bug reports and feature requests, please open an issue on GitHub.","title":"Contact"},{"location":"getting-started/","text":"Getting Started Guide This guide explains how to integrate Flask Pydantic ReDoc into your project and its basic usage. Basic Setup First, initialize Redoc in your Flask application: from flask import Flask from flask_pydantic_redoc import Redoc from pydantic import BaseModel, Field app = Flask(__name__) redoc = Redoc(app) Defining Models Define your Pydantic models: class User(BaseModel): id: int = Field(..., description=\"User ID\") username: str = Field(..., description=\"Username\") email: str = Field(..., description=\"Email address\") Route Documentation Document your routes using docstrings: @app.route('/users', methods=['GET']) def get_users(): \"\"\" Returns the list of users. --- get: summary: Get list of users. description: This endpoint retrieves the list of users from the database. responses: 200: description: Successful user list response. content: application/json: schema: type: array items: type: object properties: id: type: integer username: type: string email: type: string \"\"\" users = [ {\"id\": 1, \"username\": \"user1\", \"email\": \"user1@example.com\"}, {\"id\": 2, \"username\": \"user2\", \"email\": \"user2@example.com\"} ] return jsonify(users) CRUD Operations Examples Create User @app.route('/users', methods=['POST']) def create_user(): \"\"\" Creates a new user. --- post: summary: Create new user. description: This endpoint creates a new user record. requestBody: required: true content: application/json: schema: type: object properties: username: type: string email: type: string address: type: object properties: street: type: string city: type: string country: type: string responses: 201: description: User created successfully. content: application/json: schema: type: object properties: id: type: integer username: type: string email: type: string address: type: object properties: street: type: string city: type: string country: type: string \"\"\" return jsonify({\"message\": \"User created\"}), 201 Get User by ID @app.route('/users/<int:user_id>', methods=['GET']) def get_user(user_id): \"\"\" Retrieves information for a specific user. --- get: summary: Get user information. description: This endpoint retrieves information for the user with the specified ID. parameters: - name: user_id in: path required: true schema: type: integer responses: 200: description: User information retrieved successfully. content: application/json: schema: type: object properties: user: type: object properties: id: type: integer username: type: string email: type: string posts: type: array items: type: object properties: id: type: integer title: type: string content: type: string 404: description: User not found. \"\"\" return jsonify({\"message\": \"User information retrieved\"}) Update User @app.route('/users/<int:user_id>', methods=['PUT']) def update_user(user_id): \"\"\" Updates user information. --- put: summary: Update user information. description: This endpoint updates information for the user with the specified ID. parameters: - name: user_id in: path required: true schema: type: integer requestBody: required: true content: application/json: schema: type: object properties: username: type: string email: type: string settings: type: object properties: notifications: type: boolean theme: type: string language: type: string responses: 200: description: User information updated successfully. 404: description: User not found. \"\"\" return jsonify({\"message\": \"User updated\"}) Delete User @app.route('/users/<int:user_id>', methods=['DELETE']) def delete_user(user_id): \"\"\" Deletes a user. --- delete: summary: Delete user. description: This endpoint deletes the user with the specified ID. parameters: - name: user_id in: path required: true schema: type: integer responses: 204: description: User deleted successfully. 404: description: User not found. \"\"\" return \"\", 204 Accessing Documentation After starting your application: Access the ReDoc UI via the /docs endpoint Access the OpenAPI JSON schema via the /docs/json endpoint Configuration Configuration options to customize Redoc: config = { 'title': 'API Documentation', 'version': '1.0.0', 'openapi_version': '3.0.2', 'info': { 'title': 'API Documentation', 'version': '1.0.0', 'description': 'API documentation description' } } redoc = Redoc(app, schemas=[User], config=config) Advanced Topics For more detailed information, you can review the Pydantic Integration section.","title":"Getting Started"},{"location":"getting-started/#getting-started-guide","text":"This guide explains how to integrate Flask Pydantic ReDoc into your project and its basic usage.","title":"Getting Started Guide"},{"location":"getting-started/#basic-setup","text":"First, initialize Redoc in your Flask application: from flask import Flask from flask_pydantic_redoc import Redoc from pydantic import BaseModel, Field app = Flask(__name__) redoc = Redoc(app)","title":"Basic Setup"},{"location":"getting-started/#defining-models","text":"Define your Pydantic models: class User(BaseModel): id: int = Field(..., description=\"User ID\") username: str = Field(..., description=\"Username\") email: str = Field(..., description=\"Email address\")","title":"Defining Models"},{"location":"getting-started/#route-documentation","text":"Document your routes using docstrings: @app.route('/users', methods=['GET']) def get_users(): \"\"\" Returns the list of users. --- get: summary: Get list of users. description: This endpoint retrieves the list of users from the database. responses: 200: description: Successful user list response. content: application/json: schema: type: array items: type: object properties: id: type: integer username: type: string email: type: string \"\"\" users = [ {\"id\": 1, \"username\": \"user1\", \"email\": \"user1@example.com\"}, {\"id\": 2, \"username\": \"user2\", \"email\": \"user2@example.com\"} ] return jsonify(users)","title":"Route Documentation"},{"location":"getting-started/#crud-operations-examples","text":"","title":"CRUD Operations Examples"},{"location":"getting-started/#create-user","text":"@app.route('/users', methods=['POST']) def create_user(): \"\"\" Creates a new user. --- post: summary: Create new user. description: This endpoint creates a new user record. requestBody: required: true content: application/json: schema: type: object properties: username: type: string email: type: string address: type: object properties: street: type: string city: type: string country: type: string responses: 201: description: User created successfully. content: application/json: schema: type: object properties: id: type: integer username: type: string email: type: string address: type: object properties: street: type: string city: type: string country: type: string \"\"\" return jsonify({\"message\": \"User created\"}), 201","title":"Create User"},{"location":"getting-started/#get-user-by-id","text":"@app.route('/users/<int:user_id>', methods=['GET']) def get_user(user_id): \"\"\" Retrieves information for a specific user. --- get: summary: Get user information. description: This endpoint retrieves information for the user with the specified ID. parameters: - name: user_id in: path required: true schema: type: integer responses: 200: description: User information retrieved successfully. content: application/json: schema: type: object properties: user: type: object properties: id: type: integer username: type: string email: type: string posts: type: array items: type: object properties: id: type: integer title: type: string content: type: string 404: description: User not found. \"\"\" return jsonify({\"message\": \"User information retrieved\"})","title":"Get User by ID"},{"location":"getting-started/#update-user","text":"@app.route('/users/<int:user_id>', methods=['PUT']) def update_user(user_id): \"\"\" Updates user information. --- put: summary: Update user information. description: This endpoint updates information for the user with the specified ID. parameters: - name: user_id in: path required: true schema: type: integer requestBody: required: true content: application/json: schema: type: object properties: username: type: string email: type: string settings: type: object properties: notifications: type: boolean theme: type: string language: type: string responses: 200: description: User information updated successfully. 404: description: User not found. \"\"\" return jsonify({\"message\": \"User updated\"})","title":"Update User"},{"location":"getting-started/#delete-user","text":"@app.route('/users/<int:user_id>', methods=['DELETE']) def delete_user(user_id): \"\"\" Deletes a user. --- delete: summary: Delete user. description: This endpoint deletes the user with the specified ID. parameters: - name: user_id in: path required: true schema: type: integer responses: 204: description: User deleted successfully. 404: description: User not found. \"\"\" return \"\", 204","title":"Delete User"},{"location":"getting-started/#accessing-documentation","text":"After starting your application: Access the ReDoc UI via the /docs endpoint Access the OpenAPI JSON schema via the /docs/json endpoint","title":"Accessing Documentation"},{"location":"getting-started/#configuration","text":"Configuration options to customize Redoc: config = { 'title': 'API Documentation', 'version': '1.0.0', 'openapi_version': '3.0.2', 'info': { 'title': 'API Documentation', 'version': '1.0.0', 'description': 'API documentation description' } } redoc = Redoc(app, schemas=[User], config=config)","title":"Configuration"},{"location":"getting-started/#advanced-topics","text":"For more detailed information, you can review the Pydantic Integration section.","title":"Advanced Topics"},{"location":"installation/","text":"Installation You can follow these steps to add Flask Pydantic ReDoc to your project. Requirements Python 3.7+ Flask 2.0+ Pydantic 2.0+ Installation with Pip You can install directly from GitHub: pip install git+https://github.com/ogzcode/flask-redoc-ui Manual Installation If you don't want to install with pip, you can follow these steps for manual installation: First, install the required packages: pip install flask pydantic apispec apispec-webframeworks Create a folder named flask_pydantic_redoc in your project. Copy the following files to this folder: redoc.py - Main class for ReDoc integration pydantic_ext.py - Plugin that converts Pydantic models to OpenAPI schemas templates/redoc.html - ReDoc UI template Create an __init__.py file and add the following code: from .redoc import Redoc Required Dependencies Make sure the following packages are installed for manual installation: Flask>=3.0.0 pydantic>=2.0.0 apispec>=6.0.0 apispec-webframeworks>=1.0.0 Dependency Check After installation, you can test in the Python console to ensure all dependencies are correctly installed: from flask_pydantic_redoc import Redoc from flask import Flask app = Flask(__name__) redoc = Redoc(app) If you don't get any errors, the installation is successful. Next Steps After completing the installation, you can learn how to use Flask Pydantic ReDoc in your application by reviewing the Getting Started Guide .","title":"Installation"},{"location":"installation/#installation","text":"You can follow these steps to add Flask Pydantic ReDoc to your project.","title":"Installation"},{"location":"installation/#requirements","text":"Python 3.7+ Flask 2.0+ Pydantic 2.0+","title":"Requirements"},{"location":"installation/#installation-with-pip","text":"You can install directly from GitHub: pip install git+https://github.com/ogzcode/flask-redoc-ui","title":"Installation with Pip"},{"location":"installation/#manual-installation","text":"If you don't want to install with pip, you can follow these steps for manual installation: First, install the required packages: pip install flask pydantic apispec apispec-webframeworks Create a folder named flask_pydantic_redoc in your project. Copy the following files to this folder: redoc.py - Main class for ReDoc integration pydantic_ext.py - Plugin that converts Pydantic models to OpenAPI schemas templates/redoc.html - ReDoc UI template Create an __init__.py file and add the following code: from .redoc import Redoc","title":"Manual Installation"},{"location":"installation/#required-dependencies","text":"Make sure the following packages are installed for manual installation: Flask>=3.0.0 pydantic>=2.0.0 apispec>=6.0.0 apispec-webframeworks>=1.0.0","title":"Required Dependencies"},{"location":"installation/#dependency-check","text":"After installation, you can test in the Python console to ensure all dependencies are correctly installed: from flask_pydantic_redoc import Redoc from flask import Flask app = Flask(__name__) redoc = Redoc(app) If you don't get any errors, the installation is successful.","title":"Dependency Check"},{"location":"installation/#next-steps","text":"After completing the installation, you can learn how to use Flask Pydantic ReDoc in your application by reviewing the Getting Started Guide .","title":"Next Steps"},{"location":"pydantic/","text":"Pydantic Integration Flask Pydantic ReDoc automatically generates your API schemas using Pydantic models. In this section, you will learn how to effectively use Pydantic models. Pydantic Plugin Flask Pydantic ReDoc uses a special plugin to convert Pydantic models to OpenAPI schemas. This plugin is implemented with the PydanticPlugin class and correctly transfers all features of Pydantic models to OpenAPI schemas. from flask_pydantic_redoc import Redoc from pydantic import BaseModel, Field app = Flask(__name__) # Define your Pydantic models class User(BaseModel): id: int = Field(..., description=\"User ID\") username: str = Field(..., description=\"Username\") # Add your models when initializing Redoc redoc = Redoc(app, schemas=[User]) Contents You can find detailed information about Pydantic integration in the following sections: Model Examples - Pydantic model examples and OpenAPI schema conversions CRUD Operations - Using Pydantic models in API endpoints Registering Models with Redoc To register your models with Redoc: from flask import Flask from flask_pydantic_redoc import Redoc app = Flask(__name__) # Single model redoc = Redoc(app, schemas=[User]) # Multiple models redoc = Redoc(app, schemas=[User, Address, UserDetail, Product]) Best Practices Always add field descriptions ( description ) Set default values appropriately Add necessary validations Organize nested models logically Use type hints correctly","title":"Overview"},{"location":"pydantic/#pydantic-integration","text":"Flask Pydantic ReDoc automatically generates your API schemas using Pydantic models. In this section, you will learn how to effectively use Pydantic models.","title":"Pydantic Integration"},{"location":"pydantic/#pydantic-plugin","text":"Flask Pydantic ReDoc uses a special plugin to convert Pydantic models to OpenAPI schemas. This plugin is implemented with the PydanticPlugin class and correctly transfers all features of Pydantic models to OpenAPI schemas. from flask_pydantic_redoc import Redoc from pydantic import BaseModel, Field app = Flask(__name__) # Define your Pydantic models class User(BaseModel): id: int = Field(..., description=\"User ID\") username: str = Field(..., description=\"Username\") # Add your models when initializing Redoc redoc = Redoc(app, schemas=[User])","title":"Pydantic Plugin"},{"location":"pydantic/#contents","text":"You can find detailed information about Pydantic integration in the following sections: Model Examples - Pydantic model examples and OpenAPI schema conversions CRUD Operations - Using Pydantic models in API endpoints","title":"Contents"},{"location":"pydantic/#registering-models-with-redoc","text":"To register your models with Redoc: from flask import Flask from flask_pydantic_redoc import Redoc app = Flask(__name__) # Single model redoc = Redoc(app, schemas=[User]) # Multiple models redoc = Redoc(app, schemas=[User, Address, UserDetail, Product])","title":"Registering Models with Redoc"},{"location":"pydantic/#best-practices","text":"Always add field descriptions ( description ) Set default values appropriately Add necessary validations Organize nested models logically Use type hints correctly","title":"Best Practices"},{"location":"pydantic/crud/","text":"CRUD Operations and Using $ref After defining your Pydantic models, you can reference them in your API endpoint docstrings. This makes your documentation cleaner and easier to maintain. Model Definitions First, let's define the models we'll use: from pydantic import BaseModel, Field from typing import List, Optional class Address(BaseModel): street: str = Field(..., description=\"Street name\") city: str = Field(..., description=\"City\") country: str = Field(..., description=\"Country\") class User(BaseModel): id: int = Field(..., description=\"User ID\") username: str = Field(..., description=\"Username\") email: str = Field(..., description=\"Email address\") is_active: bool = Field(default=True, description=\"Is the user active?\") address: Optional[Address] = Field(None, description=\"Address information\") class Post(BaseModel): id: int = Field(..., description=\"Post ID\") title: str = Field(..., description=\"Post title\") content: str = Field(..., description=\"Post content\") user_id: int = Field(..., description=\"User ID\") class UserCreate(BaseModel): username: str = Field(..., description=\"Username\") email: str = Field(..., description=\"Email address\") address: Optional[Address] = Field(None, description=\"Address information\") class UserUpdate(BaseModel): username: Optional[str] = Field(None, description=\"Username\") email: Optional[str] = Field(None, description=\"Email address\") is_active: Optional[bool] = Field(None, description=\"Is the user active?\") address: Optional[Address] = Field(None, description=\"Address information\") CRUD Endpoints Now, let's define endpoints that implement CRUD operations using these models: User Listing (Read - List) @app.route('/users', methods=['GET']) def get_users(): \"\"\" Returns the list of users. --- get: summary: Get list of users. description: This endpoint retrieves the list of users from the database. responses: 200: description: Successful user list response. content: application/json: schema: type: array items: $ref: '#/components/schemas/User' \"\"\" # Implementation code... return jsonify([]) User Creation (Create) @app.route('/users', methods=['POST']) def create_user(): \"\"\" Creates a new user. --- post: summary: Create new user. description: This endpoint creates a new user record. requestBody: required: true content: application/json: schema: $ref: '#/components/schemas/UserCreate' responses: 201: description: User created successfully. content: application/json: schema: $ref: '#/components/schemas/User' \"\"\" # Implementation code... return jsonify({}), 201 User Detail (Read - Detail) @app.route('/users/<int:user_id>', methods=['GET']) def get_user(user_id): \"\"\" Retrieves information for a specific user. --- get: summary: Get user information. description: This endpoint retrieves information for the user with the specified ID. parameters: - name: user_id in: path required: true schema: type: integer responses: 200: description: User information retrieved successfully. content: application/json: schema: type: object properties: user: $ref: '#/components/schemas/User' posts: type: array items: $ref: '#/components/schemas/Post' 404: description: User not found. \"\"\" # Implementation code... return jsonify({}) User Update (Update) @app.route('/users/<int:user_id>', methods=['PUT']) def update_user(user_id): \"\"\" Updates user information. --- put: summary: Update user information. description: This endpoint updates information for the user with the specified ID. parameters: - name: user_id in: path required: true schema: type: integer requestBody: required: true content: application/json: schema: $ref: '#/components/schemas/UserUpdate' responses: 200: description: User information updated successfully. content: application/json: schema: $ref: '#/components/schemas/User' 404: description: User not found. \"\"\" # Implementation code... return jsonify({}) User Deletion (Delete) @app.route('/users/<int:user_id>', methods=['DELETE']) def delete_user(user_id): \"\"\" Deletes a user. --- delete: summary: Delete user. description: This endpoint deletes the user with the specified ID. parameters: - name: user_id in: path required: true schema: type: integer responses: 204: description: User deleted successfully. 404: description: User not found. \"\"\" # Implementation code... return \"\", 204 CRUD Operations with Related Models Endpoints for managing a user's posts: Post Creation @app.route('/users/<int:user_id>/posts', methods=['POST']) def create_post(user_id): \"\"\" Creates a new post for a user. --- post: summary: Create new post. description: This endpoint creates a new post for the specified user. parameters: - name: user_id in: path required: true schema: type: integer requestBody: required: true content: application/json: schema: type: object properties: title: type: string content: type: string responses: 201: description: Post created successfully. content: application/json: schema: $ref: '#/components/schemas/Post' 404: description: User not found. \"\"\" # Implementation code... return jsonify({}), 201 Listing User's Posts @app.route('/users/<int:user_id>/posts', methods=['GET']) def get_user_posts(user_id): \"\"\" Lists a user's posts. --- get: summary: Get user posts. description: This endpoint retrieves all posts for the specified user. parameters: - name: user_id in: path required: true schema: type: integer responses: 200: description: Posts retrieved successfully. content: application/json: schema: type: array items: $ref: '#/components/schemas/Post' 404: description: User not found. \"\"\" # Implementation code... return jsonify([]) Best Practices Always use $ref to reference models Write detailed docstrings for endpoints Clearly specify request and response schemas Document error cases Specify parameters and their requirements","title":"CRUD Operations"},{"location":"pydantic/crud/#crud-operations-and-using-ref","text":"After defining your Pydantic models, you can reference them in your API endpoint docstrings. This makes your documentation cleaner and easier to maintain.","title":"CRUD Operations and Using $ref"},{"location":"pydantic/crud/#model-definitions","text":"First, let's define the models we'll use: from pydantic import BaseModel, Field from typing import List, Optional class Address(BaseModel): street: str = Field(..., description=\"Street name\") city: str = Field(..., description=\"City\") country: str = Field(..., description=\"Country\") class User(BaseModel): id: int = Field(..., description=\"User ID\") username: str = Field(..., description=\"Username\") email: str = Field(..., description=\"Email address\") is_active: bool = Field(default=True, description=\"Is the user active?\") address: Optional[Address] = Field(None, description=\"Address information\") class Post(BaseModel): id: int = Field(..., description=\"Post ID\") title: str = Field(..., description=\"Post title\") content: str = Field(..., description=\"Post content\") user_id: int = Field(..., description=\"User ID\") class UserCreate(BaseModel): username: str = Field(..., description=\"Username\") email: str = Field(..., description=\"Email address\") address: Optional[Address] = Field(None, description=\"Address information\") class UserUpdate(BaseModel): username: Optional[str] = Field(None, description=\"Username\") email: Optional[str] = Field(None, description=\"Email address\") is_active: Optional[bool] = Field(None, description=\"Is the user active?\") address: Optional[Address] = Field(None, description=\"Address information\")","title":"Model Definitions"},{"location":"pydantic/crud/#crud-endpoints","text":"Now, let's define endpoints that implement CRUD operations using these models:","title":"CRUD Endpoints"},{"location":"pydantic/crud/#user-listing-read-list","text":"@app.route('/users', methods=['GET']) def get_users(): \"\"\" Returns the list of users. --- get: summary: Get list of users. description: This endpoint retrieves the list of users from the database. responses: 200: description: Successful user list response. content: application/json: schema: type: array items: $ref: '#/components/schemas/User' \"\"\" # Implementation code... return jsonify([])","title":"User Listing (Read - List)"},{"location":"pydantic/crud/#user-creation-create","text":"@app.route('/users', methods=['POST']) def create_user(): \"\"\" Creates a new user. --- post: summary: Create new user. description: This endpoint creates a new user record. requestBody: required: true content: application/json: schema: $ref: '#/components/schemas/UserCreate' responses: 201: description: User created successfully. content: application/json: schema: $ref: '#/components/schemas/User' \"\"\" # Implementation code... return jsonify({}), 201","title":"User Creation (Create)"},{"location":"pydantic/crud/#user-detail-read-detail","text":"@app.route('/users/<int:user_id>', methods=['GET']) def get_user(user_id): \"\"\" Retrieves information for a specific user. --- get: summary: Get user information. description: This endpoint retrieves information for the user with the specified ID. parameters: - name: user_id in: path required: true schema: type: integer responses: 200: description: User information retrieved successfully. content: application/json: schema: type: object properties: user: $ref: '#/components/schemas/User' posts: type: array items: $ref: '#/components/schemas/Post' 404: description: User not found. \"\"\" # Implementation code... return jsonify({})","title":"User Detail (Read - Detail)"},{"location":"pydantic/crud/#user-update-update","text":"@app.route('/users/<int:user_id>', methods=['PUT']) def update_user(user_id): \"\"\" Updates user information. --- put: summary: Update user information. description: This endpoint updates information for the user with the specified ID. parameters: - name: user_id in: path required: true schema: type: integer requestBody: required: true content: application/json: schema: $ref: '#/components/schemas/UserUpdate' responses: 200: description: User information updated successfully. content: application/json: schema: $ref: '#/components/schemas/User' 404: description: User not found. \"\"\" # Implementation code... return jsonify({})","title":"User Update (Update)"},{"location":"pydantic/crud/#user-deletion-delete","text":"@app.route('/users/<int:user_id>', methods=['DELETE']) def delete_user(user_id): \"\"\" Deletes a user. --- delete: summary: Delete user. description: This endpoint deletes the user with the specified ID. parameters: - name: user_id in: path required: true schema: type: integer responses: 204: description: User deleted successfully. 404: description: User not found. \"\"\" # Implementation code... return \"\", 204","title":"User Deletion (Delete)"},{"location":"pydantic/crud/#crud-operations-with-related-models","text":"Endpoints for managing a user's posts:","title":"CRUD Operations with Related Models"},{"location":"pydantic/crud/#post-creation","text":"@app.route('/users/<int:user_id>/posts', methods=['POST']) def create_post(user_id): \"\"\" Creates a new post for a user. --- post: summary: Create new post. description: This endpoint creates a new post for the specified user. parameters: - name: user_id in: path required: true schema: type: integer requestBody: required: true content: application/json: schema: type: object properties: title: type: string content: type: string responses: 201: description: Post created successfully. content: application/json: schema: $ref: '#/components/schemas/Post' 404: description: User not found. \"\"\" # Implementation code... return jsonify({}), 201","title":"Post Creation"},{"location":"pydantic/crud/#listing-users-posts","text":"@app.route('/users/<int:user_id>/posts', methods=['GET']) def get_user_posts(user_id): \"\"\" Lists a user's posts. --- get: summary: Get user posts. description: This endpoint retrieves all posts for the specified user. parameters: - name: user_id in: path required: true schema: type: integer responses: 200: description: Posts retrieved successfully. content: application/json: schema: type: array items: $ref: '#/components/schemas/Post' 404: description: User not found. \"\"\" # Implementation code... return jsonify([])","title":"Listing User's Posts"},{"location":"pydantic/crud/#best-practices","text":"Always use $ref to reference models Write detailed docstrings for endpoints Clearly specify request and response schemas Document error cases Specify parameters and their requirements","title":"Best Practices"},{"location":"pydantic/models/","text":"Pydantic Model Examples In this section, you will see various Pydantic model examples that you can use with Flask Pydantic ReDoc and how they are converted to OpenAPI schemas. Basic Model A Pydantic model can be defined in its simplest form as follows: from pydantic import BaseModel, Field from typing import Optional, List class User(BaseModel): id: int = Field(..., description=\"User ID\") username: str = Field(..., description=\"Username\") email: str = Field(..., description=\"Email address\") is_active: bool = Field(default=True, description=\"Is the user active?\") This model will appear in the OpenAPI schema as follows: { \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"integer\", \"description\": \"User ID\" }, \"username\": { \"type\": \"string\", \"description\": \"Username\" }, \"email\": { \"type\": \"string\", \"description\": \"Email address\" }, \"is_active\": { \"type\": \"boolean\", \"description\": \"Is the user active?\", \"default\": true } }, \"required\": [\"id\", \"username\", \"email\"] } Nested Models Pydantic supports nested models, and these models are correctly represented in OpenAPI schemas: class Address(BaseModel): street: str = Field(..., description=\"Street name\") city: str = Field(..., description=\"City\") country: str = Field(..., description=\"Country\") class UserDetail(BaseModel): user: User = Field(..., description=\"User information\") address: Optional[Address] = Field(None, description=\"Address information\") interests: List[str] = Field(default_factory=list, description=\"Interests\") This nested model will appear in the OpenAPI schema as follows: { \"type\": \"object\", \"properties\": { \"user\": { \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"integer\", \"description\": \"User ID\" }, \"username\": { \"type\": \"string\", \"description\": \"Username\" }, \"email\": { \"type\": \"string\", \"description\": \"Email address\" }, \"is_active\": { \"type\": \"boolean\", \"description\": \"Is the user active?\", \"default\": true } }, \"required\": [\"id\", \"username\", \"email\"], \"description\": \"User information\" }, \"address\": { \"type\": \"object\", \"properties\": { \"street\": { \"type\": \"string\", \"description\": \"Street name\" }, \"city\": { \"type\": \"string\", \"description\": \"City\" }, \"country\": { \"type\": \"string\", \"description\": \"Country\" } }, \"required\": [\"street\", \"city\", \"country\"], \"description\": \"Address information\" }, \"interests\": { \"type\": \"array\", \"items\": { \"type\": \"string\" }, \"description\": \"Interests\", \"default\": [] } }, \"required\": [\"user\"] } Using Field You can enrich your model fields with the Pydantic Field class: class Product(BaseModel): id: int = Field(..., description=\"Product ID\", gt=0) name: str = Field(..., description=\"Product name\", min_length=3) price: float = Field(..., description=\"Product price\", ge=0) stock: int = Field(default=0, description=\"Stock quantity\", ge=0) tags: List[str] = Field( default_factory=list, description=\"Product tags\", max_items=5 ) This model will appear in the OpenAPI schema as follows: { \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"integer\", \"description\": \"Product ID\", \"exclusiveMinimum\": 0 }, \"name\": { \"type\": \"string\", \"description\": \"Product name\", \"minLength\": 3 }, \"price\": { \"type\": \"number\", \"description\": \"Product price\", \"minimum\": 0 }, \"stock\": { \"type\": \"integer\", \"description\": \"Stock quantity\", \"minimum\": 0, \"default\": 0 }, \"tags\": { \"type\": \"array\", \"items\": { \"type\": \"string\" }, \"description\": \"Product tags\", \"maxItems\": 5, \"default\": [] } }, \"required\": [\"id\", \"name\", \"price\"] } Complex Model Examples Related Models You can also define more complex related models: class Comment(BaseModel): id: int = Field(..., description=\"Comment ID\") content: str = Field(..., description=\"Comment content\") created_at: str = Field(..., description=\"Creation date\") class Post(BaseModel): id: int = Field(..., description=\"Post ID\") title: str = Field(..., description=\"Post title\") content: str = Field(..., description=\"Post content\") comments: List[Comment] = Field(default_factory=list, description=\"Comments\") tags: List[str] = Field(default_factory=list, description=\"Tags\") class UserProfile(BaseModel): user: User = Field(..., description=\"User information\") posts: List[Post] = Field(default_factory=list, description=\"User's posts\") followers_count: int = Field(default=0, description=\"Followers count\") following_count: int = Field(default=0, description=\"Following count\") These related models will appear in the OpenAPI schema as follows: { \"UserProfile\": { \"type\": \"object\", \"properties\": { \"user\": { \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"integer\", \"description\": \"User ID\" }, \"username\": { \"type\": \"string\", \"description\": \"Username\" }, \"email\": { \"type\": \"string\", \"description\": \"Email address\" }, \"is_active\": { \"type\": \"boolean\", \"description\": \"Is the user active?\", \"default\": true } }, \"required\": [\"id\", \"username\", \"email\"], \"description\": \"User information\" }, \"posts\": { \"type\": \"array\", \"items\": { \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"integer\", \"description\": \"Post ID\" }, \"title\": { \"type\": \"string\", \"description\": \"Post title\" }, \"content\": { \"type\": \"string\", \"description\": \"Post content\" }, \"comments\": { \"type\": \"array\", \"items\": { \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"integer\", \"description\": \"Comment ID\" }, \"content\": { \"type\": \"string\", \"description\": \"Comment content\" }, \"created_at\": { \"type\": \"string\", \"description\": \"Creation date\" } }, \"required\": [\"id\", \"content\", \"created_at\"] }, \"description\": \"Comments\", \"default\": [] }, \"tags\": { \"type\": \"array\", \"items\": { \"type\": \"string\" }, \"description\": \"Tags\", \"default\": [] } }, \"required\": [\"id\", \"title\", \"content\"] }, \"description\": \"User's posts\", \"default\": [] }, \"followers_count\": { \"type\": \"integer\", \"description\": \"Followers count\", \"default\": 0 }, \"following_count\": { \"type\": \"integer\", \"description\": \"Following count\", \"default\": 0 } }, \"required\": [\"user\"] } } Using Enums Pydantic also supports Python enums: from enum import Enum class UserRole(str, Enum): ADMIN = \"admin\" MODERATOR = \"moderator\" USER = \"user\" class UserWithRole(BaseModel): id: int = Field(..., description=\"User ID\") username: str = Field(..., description=\"Username\") role: UserRole = Field(default=UserRole.USER, description=\"User role\") This model will appear in the OpenAPI schema as follows: { \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"integer\", \"description\": \"User ID\" }, \"username\": { \"type\": \"string\", \"description\": \"Username\" }, \"role\": { \"type\": \"string\", \"description\": \"User role\", \"default\": \"user\", \"enum\": [\"admin\", \"moderator\", \"user\"] } }, \"required\": [\"id\", \"username\"] } Date and Time Fields Pydantic also supports date and time fields: from datetime import datetime, date from pydantic import BaseModel, Field class Event(BaseModel): id: int = Field(..., description=\"Event ID\") title: str = Field(..., description=\"Event title\") event_date: date = Field(..., description=\"Event date\") created_at: datetime = Field(default_factory=datetime.now, description=\"Creation time\") This model will appear in the OpenAPI schema as follows: { \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"integer\", \"description\": \"Event ID\" }, \"title\": { \"type\": \"string\", \"description\": \"Event title\" }, \"event_date\": { \"type\": \"string\", \"format\": \"date\", \"description\": \"Event date\" }, \"created_at\": { \"type\": \"string\", \"format\": \"date-time\", \"description\": \"Creation time\" } }, \"required\": [\"id\", \"title\", \"event_date\"] } Best Practices Always add field descriptions ( description ) Set default values appropriately Add necessary validations Organize nested models logically Use type hints correctly","title":"Model Examples"},{"location":"pydantic/models/#pydantic-model-examples","text":"In this section, you will see various Pydantic model examples that you can use with Flask Pydantic ReDoc and how they are converted to OpenAPI schemas.","title":"Pydantic Model Examples"},{"location":"pydantic/models/#basic-model","text":"A Pydantic model can be defined in its simplest form as follows: from pydantic import BaseModel, Field from typing import Optional, List class User(BaseModel): id: int = Field(..., description=\"User ID\") username: str = Field(..., description=\"Username\") email: str = Field(..., description=\"Email address\") is_active: bool = Field(default=True, description=\"Is the user active?\") This model will appear in the OpenAPI schema as follows: { \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"integer\", \"description\": \"User ID\" }, \"username\": { \"type\": \"string\", \"description\": \"Username\" }, \"email\": { \"type\": \"string\", \"description\": \"Email address\" }, \"is_active\": { \"type\": \"boolean\", \"description\": \"Is the user active?\", \"default\": true } }, \"required\": [\"id\", \"username\", \"email\"] }","title":"Basic Model"},{"location":"pydantic/models/#nested-models","text":"Pydantic supports nested models, and these models are correctly represented in OpenAPI schemas: class Address(BaseModel): street: str = Field(..., description=\"Street name\") city: str = Field(..., description=\"City\") country: str = Field(..., description=\"Country\") class UserDetail(BaseModel): user: User = Field(..., description=\"User information\") address: Optional[Address] = Field(None, description=\"Address information\") interests: List[str] = Field(default_factory=list, description=\"Interests\") This nested model will appear in the OpenAPI schema as follows: { \"type\": \"object\", \"properties\": { \"user\": { \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"integer\", \"description\": \"User ID\" }, \"username\": { \"type\": \"string\", \"description\": \"Username\" }, \"email\": { \"type\": \"string\", \"description\": \"Email address\" }, \"is_active\": { \"type\": \"boolean\", \"description\": \"Is the user active?\", \"default\": true } }, \"required\": [\"id\", \"username\", \"email\"], \"description\": \"User information\" }, \"address\": { \"type\": \"object\", \"properties\": { \"street\": { \"type\": \"string\", \"description\": \"Street name\" }, \"city\": { \"type\": \"string\", \"description\": \"City\" }, \"country\": { \"type\": \"string\", \"description\": \"Country\" } }, \"required\": [\"street\", \"city\", \"country\"], \"description\": \"Address information\" }, \"interests\": { \"type\": \"array\", \"items\": { \"type\": \"string\" }, \"description\": \"Interests\", \"default\": [] } }, \"required\": [\"user\"] }","title":"Nested Models"},{"location":"pydantic/models/#using-field","text":"You can enrich your model fields with the Pydantic Field class: class Product(BaseModel): id: int = Field(..., description=\"Product ID\", gt=0) name: str = Field(..., description=\"Product name\", min_length=3) price: float = Field(..., description=\"Product price\", ge=0) stock: int = Field(default=0, description=\"Stock quantity\", ge=0) tags: List[str] = Field( default_factory=list, description=\"Product tags\", max_items=5 ) This model will appear in the OpenAPI schema as follows: { \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"integer\", \"description\": \"Product ID\", \"exclusiveMinimum\": 0 }, \"name\": { \"type\": \"string\", \"description\": \"Product name\", \"minLength\": 3 }, \"price\": { \"type\": \"number\", \"description\": \"Product price\", \"minimum\": 0 }, \"stock\": { \"type\": \"integer\", \"description\": \"Stock quantity\", \"minimum\": 0, \"default\": 0 }, \"tags\": { \"type\": \"array\", \"items\": { \"type\": \"string\" }, \"description\": \"Product tags\", \"maxItems\": 5, \"default\": [] } }, \"required\": [\"id\", \"name\", \"price\"] }","title":"Using Field"},{"location":"pydantic/models/#complex-model-examples","text":"","title":"Complex Model Examples"},{"location":"pydantic/models/#related-models","text":"You can also define more complex related models: class Comment(BaseModel): id: int = Field(..., description=\"Comment ID\") content: str = Field(..., description=\"Comment content\") created_at: str = Field(..., description=\"Creation date\") class Post(BaseModel): id: int = Field(..., description=\"Post ID\") title: str = Field(..., description=\"Post title\") content: str = Field(..., description=\"Post content\") comments: List[Comment] = Field(default_factory=list, description=\"Comments\") tags: List[str] = Field(default_factory=list, description=\"Tags\") class UserProfile(BaseModel): user: User = Field(..., description=\"User information\") posts: List[Post] = Field(default_factory=list, description=\"User's posts\") followers_count: int = Field(default=0, description=\"Followers count\") following_count: int = Field(default=0, description=\"Following count\") These related models will appear in the OpenAPI schema as follows: { \"UserProfile\": { \"type\": \"object\", \"properties\": { \"user\": { \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"integer\", \"description\": \"User ID\" }, \"username\": { \"type\": \"string\", \"description\": \"Username\" }, \"email\": { \"type\": \"string\", \"description\": \"Email address\" }, \"is_active\": { \"type\": \"boolean\", \"description\": \"Is the user active?\", \"default\": true } }, \"required\": [\"id\", \"username\", \"email\"], \"description\": \"User information\" }, \"posts\": { \"type\": \"array\", \"items\": { \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"integer\", \"description\": \"Post ID\" }, \"title\": { \"type\": \"string\", \"description\": \"Post title\" }, \"content\": { \"type\": \"string\", \"description\": \"Post content\" }, \"comments\": { \"type\": \"array\", \"items\": { \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"integer\", \"description\": \"Comment ID\" }, \"content\": { \"type\": \"string\", \"description\": \"Comment content\" }, \"created_at\": { \"type\": \"string\", \"description\": \"Creation date\" } }, \"required\": [\"id\", \"content\", \"created_at\"] }, \"description\": \"Comments\", \"default\": [] }, \"tags\": { \"type\": \"array\", \"items\": { \"type\": \"string\" }, \"description\": \"Tags\", \"default\": [] } }, \"required\": [\"id\", \"title\", \"content\"] }, \"description\": \"User's posts\", \"default\": [] }, \"followers_count\": { \"type\": \"integer\", \"description\": \"Followers count\", \"default\": 0 }, \"following_count\": { \"type\": \"integer\", \"description\": \"Following count\", \"default\": 0 } }, \"required\": [\"user\"] } }","title":"Related Models"},{"location":"pydantic/models/#using-enums","text":"Pydantic also supports Python enums: from enum import Enum class UserRole(str, Enum): ADMIN = \"admin\" MODERATOR = \"moderator\" USER = \"user\" class UserWithRole(BaseModel): id: int = Field(..., description=\"User ID\") username: str = Field(..., description=\"Username\") role: UserRole = Field(default=UserRole.USER, description=\"User role\") This model will appear in the OpenAPI schema as follows: { \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"integer\", \"description\": \"User ID\" }, \"username\": { \"type\": \"string\", \"description\": \"Username\" }, \"role\": { \"type\": \"string\", \"description\": \"User role\", \"default\": \"user\", \"enum\": [\"admin\", \"moderator\", \"user\"] } }, \"required\": [\"id\", \"username\"] }","title":"Using Enums"},{"location":"pydantic/models/#date-and-time-fields","text":"Pydantic also supports date and time fields: from datetime import datetime, date from pydantic import BaseModel, Field class Event(BaseModel): id: int = Field(..., description=\"Event ID\") title: str = Field(..., description=\"Event title\") event_date: date = Field(..., description=\"Event date\") created_at: datetime = Field(default_factory=datetime.now, description=\"Creation time\") This model will appear in the OpenAPI schema as follows: { \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"integer\", \"description\": \"Event ID\" }, \"title\": { \"type\": \"string\", \"description\": \"Event title\" }, \"event_date\": { \"type\": \"string\", \"format\": \"date\", \"description\": \"Event date\" }, \"created_at\": { \"type\": \"string\", \"format\": \"date-time\", \"description\": \"Creation time\" } }, \"required\": [\"id\", \"title\", \"event_date\"] }","title":"Date and Time Fields"},{"location":"pydantic/models/#best-practices","text":"Always add field descriptions ( description ) Set default values appropriately Add necessary validations Organize nested models logically Use type hints correctly","title":"Best Practices"}]}